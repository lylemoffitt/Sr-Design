#include <HardwareSerial.h>
#include <Print.h>
#include <stdbool.h>
#include <stddef.h>
#include <Arduino.h>
#include <avr/pgmspace.h>

//#include "SD_ctrl.h"

//#include <Sd2Card.h>


#define DEBUG_ERRORS

#include <stdint.h>
#include "SD_SPI.h"
#include <SPI.h>


/// Size of a block in bytes
#define SD_Block_Size 512
/// Number of blocks to test.
/// (==1) - Single block test
/// ( >1) = Multi-block test
#define SD_Block_Test_Count 1
/// Test using sequential data (vs random data)
#define TEST_SEQUENTIAL // commend out to test function with random data


typedef struct{ uint8_t dat[SD_Block_Size]; } block;

//----------------------------------------------------------------------------
#ifndef TEST_SEQUENTIAL
#if (SD_Block_Size % 64) || (SD_Block_Size < 64) || (SD_Block_Size > 512)
#error SD_Block_Size is invalid.
#endif
// 512 random Bytes
//PROGMEM
const static uint8_t random_block[SD_Block_Size]  =
{// 16 bytes per line
#if SD_Block_Size >= 64
0xbc,0xa7,0x95,0x10,0x86,0x19,0x37,0x49,0xb5,0xe3,0xf0,0xba,0xee,0xac,0xe4,0x18,
0x9e,0xf6,0x52,0x42,0x18,0x08,0x36,0xb3,0x01,0xf1,0x0a,0xc3,0xb7,0x09,0x3e,0xd8,
0x76,0x18,0x79,0x98,0x0b,0x14,0xcd,0x0d,0x14,0xa2,0x7e,0xbf,0x52,0x5c,0x61,0x13,
0x18,0x2e,0x54,0x60,0x9b,0xbb,0x6b,0x94,0xf3,0x21,0xc2,0x52,0x1d,0x6c,0x73,0xb1,
#endif
#if SD_Block_Size >= 128
0x86,0xc6,0xb6,0x4d,0x8f,0x8d,0x95,0x58,0x66,0x91,0xee,0x13,0xb5,0x81,0xfc,0xd1,
0xfc,0x7e,0x2a,0xc9,0x7c,0xe1,0x90,0x0f,0xe1,0x87,0x7d,0x6d,0x25,0x10,0x2f,0xa5,
0x2b,0xe2,0x41,0x4e,0xaa,0xb0,0x2c,0xc6,0x23,0x43,0x83,0x6b,0x02,0xef,0x9a,0x7a,
0x8d,0xe0,0x9d,0xa0,0x83,0x46,0xf0,0x3a,0x6d,0x32,0x92,0x45,0x92,0xbf,0x53,0x4a,
#endif
#if SD_Block_Size >= 192
0xbb,0x69,0xd0,0xe3,0xad,0x70,0x43,0xdf,0x50,0x70,0x24,0xdc,0x08,0x85,0x2e,0x33,
0x96,0x2d,0x15,0xc8,0x6f,0x36,0xea,0xd4,0xfb,0x00,0x58,0x56,0x9c,0x96,0x74,0xaa,
0xea,0x77,0x1c,0x97,0x20,0x82,0x70,0xb5,0x48,0x95,0x9f,0xe1,0xe9,0xfe,0x4d,0x12,
0x26,0x2f,0x18,0x19,0x67,0xe4,0x78,0xed,0xdf,0x76,0x08,0xcf,0x30,0x82,0x52,0xdb,
#endif
#if SD_Block_Size >= 256
0x67,0x96,0xc5,0x0b,0xe0,0x5c,0x15,0x55,0x02,0x94,0x8e,0xb7,0x28,0xbf,0x5d,0xac,
0xf5,0x34,0x73,0xa8,0x07,0x75,0x62,0x4e,0x24,0xcf,0x6d,0xe2,0xe9,0x87,0xe6,0x1f,
0xbd,0x1c,0x96,0x5d,0x25,0x82,0xe1,0x9f,0x53,0x7e,0x5d,0x90,0x53,0xb0,0x0d,0x95,
0x75,0x7c,0xd5,0xfc,0x63,0x6f,0xbd,0xa9,0x80,0xc2,0x63,0x25,0x5e,0x09,0xf9,0xa6,
#endif
#if SD_Block_Size >= 320
0xc9,0xcc,0xf5,0xfe,0x67,0x91,0x44,0x41,0x00,0x17,0x1c,0x48,0x8f,0x26,0x4d,0x95,
0x15,0x04,0x38,0x8c,0x90,0x24,0x5b,0xfb,0xd4,0x37,0x4a,0x84,0xc1,0xa0,0x8c,0xfc,
0x52,0xc6,0xb5,0x43,0x3d,0x9e,0x23,0xb4,0x9d,0xcc,0xb4,0xb4,0x06,0x59,0x33,0x75,
0x1d,0xb5,0x12,0xa9,0xe3,0x97,0xed,0x17,0xee,0x84,0xbe,0xc8,0xf9,0x23,0x01,0x97,
#endif
#if SD_Block_Size >= 384
0x37,0x71,0x53,0x0c,0x0b,0xc0,0xb1,0xce,0x8f,0x05,0xb5,0x83,0x74,0x45,0x82,0x0c,
0x1c,0xd3,0x9c,0x1c,0x05,0x6a,0x8a,0x0e,0x25,0xff,0x00,0xe3,0x53,0xc8,0x9c,0xc0,
0x40,0xe2,0x60,0x1f,0xa7,0xea,0xa1,0x8e,0x0c,0x56,0x57,0xb7,0x71,0x52,0x07,0xb0,
0x1a,0x15,0x43,0xd6,0xcc,0x7c,0xb1,0x74,0xe3,0x44,0x19,0xac,0x97,0x96,0xb9,0xd5,
#endif
#if SD_Block_Size >= 448
0x9e,0x3d,0x7e,0x15,0xd0,0xd5,0x8e,0xcf,0xad,0x7b,0xf9,0x0d,0x13,0xca,0x37,0xc1,
0x2e,0x49,0x45,0xe2,0xc1,0x96,0xac,0x4e,0x47,0xed,0xa9,0xec,0x94,0x1d,0xdd,0x11,
0x94,0xf3,0x80,0x88,0xd1,0x22,0xff,0x22,0xcf,0x42,0x03,0x35,0x74,0x10,0x4b,0x3c,
0xf7,0x49,0xc4,0x2b,0x6d,0x81,0x42,0xfc,0xb3,0x7f,0x19,0x8e,0xc2,0xdd,0x38,0x85,
#endif
#if SD_Block_Size >= 512
0xb5,0xd9,0xee,0xe5,0xfd,0xbb,0xf3,0xdb,0x60,0xc8,0x84,0xfd,0x9a,0x97,0x79,0x7e,
0x69,0xab,0x54,0x96,0x3c,0x7a,0xcb,0x7a,0x29,0xdc,0xf8,0x4c,0x24,0x2c,0x99,0xf1,
0x6f,0x04,0x27,0x35,0x0d,0xca,0x62,0x5b,0xfc,0xeb,0x4c,0xd5,0xc2,0x93,0xf2,0xa9,
0x31,0xf3,0x3a,0xff,0x49,0xa0,0xbc,0xbc,0x55,0xeb,0x3d,0xa9,0x02,0x21,0xe1,0x48,
#endif
};
#  define TEST_DATA random_block


#else

static block   		test;
#  define TEST_DATA test.dat

#endif

static block   		buffer[SD_Block_Test_Count];
                            

                            
static uint8_t    	CS_pin = 4;
                            
static uint32_t		blockAddr = 0;
                            
static Sd2Card  	SDC;



//----------------------------------------------------------------------------
//The setup function is called once at startup of the sketch
void setup()
{
//        SDC = new Sd2Card();
	SDC.begin( CS_pin, SPI_FULL_SPEED );
	for( size_t i=0; i<SD_Block_Test_Count; ++i)
	{	fillBlock( buffer[i].dat );
	}
	
	Serial.begin(9600);
	Serial.print("Setup Complete!");
}

//----------------------------------------------------------------------------
// The loop function is called in an endless loop
void loop()
{
// Perform read-write test on multiple blocks
#if SD_Block_Test_Count > 1
	// Multi-block write test
	SDC.writeStart( blockAddr , SD_Block_Test_Count );
	for( size_t i=0; i<SD_Block_Test_Count; ++i)
		SDC.writeData( buffer[i].dat );
	SDC.writeStop();

	for( size_t i=0; i<SD_Block_Test_Count; ++i)
	{	eraseBlock( buffer[i].dat );
	}
	// Multi-block read test
	SDC.readStart( blockAddr );
	for( size_t i=0; i<SD_Block_Test_Count; ++i)
		SDC.readData( buffer[i].dat );
	SDC.readStop();

#endif

// Perform read-write test on one block
#if SD_Block_Test_Count == 1
	// Single-block write test
	SDC.writeBlock( blockAddr, buffer[0].dat );
	
	for( size_t i; i<SD_Block_Test_Count; ++i)
	{	eraseBlock( buffer[i].dat );
	}
	// Single-block read test
	SDC.readBlock( blockAddr, buffer[0].dat );
	

#endif

#if SD_Block_Test_Count
	for( size_t i=0; i<SD_Block_Test_Count; ++i)
	{
		Serial.print( "Block number " );
		Serial.print( i );
		if( verifyBlock( buffer[i].dat ) ){
			Serial.print( " does not match." );
			printBlock( buffer[i].dat );
		}else{
			Serial.print( " matches." );
		}
	}
#endif

	while(1);
}

inline
void fillBlock( uint8_t * dat ){
	for( uint32_t ii=0; ii<SD_Block_Size; ii++){
		dat[ii] = TEST_DATA[ii];
	}
}
inline
void eraseBlock( uint8_t * dat ){
	for( uint32_t ii=0; ii<SD_Block_Size; ii++){
		dat[ii] = 0;
	}
}
inline
bool verifyBlock( uint8_t * dat ){
	for( uint32_t ii=0; ii<SD_Block_Size; ii++){
		if( dat[ii] != TEST_DATA[ii] ){ return false; }
	}
	return true;
}
inline
void printBlock( uint8_t * dat ){
	for( uint32_t ii=0; ii<SD_Block_Size; ii++){
		Serial.print( dat[ii] , HEX );
	}
}



