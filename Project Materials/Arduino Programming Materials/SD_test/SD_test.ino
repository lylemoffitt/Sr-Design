#include <HardwareSerial.h>
#include <Print.h>
#include <stdbool.h>
#include <stddef.h>
#include <Arduino.h>
#include <avr/pgmspace.h>

//#include "SD_ctrl.h"

//#include <Sd2Card.h>

#define DEBUG_ERRORS
#define USE_SD_CRC 1

#include <stdint.h>
#include "SD_SPI.h"
#include <SPI.h>

/// Size of a block in bytes
#define SD_Block_Size 128
/// Number of blocks to test.
/// (==1) - Single block test
/// ( >1) = Multi-block test
#define SD_Block_Test_Count 1
/// Test using sequential data (vs random data)
//#define TEST_SEQUENTIAL // commend out to test function with random data

typedef struct
{
	uint8_t dat[SD_Block_Size];
} block;

//----------------------------------------------------------------------------
#ifndef TEST_SEQUENTIAL
#if (SD_Block_Size % 64) || (SD_Block_Size < 64) || (SD_Block_Size > 512)
#error SD_Block_Size is invalid.
#endif
// 512 random Bytes
//PROGMEM
const static uint8_t random_block[SD_Block_Size] =
{ // 16 bytes per line
#if SD_Block_Size >= 64
	0xbc,0xa7,0x95,0x10,0x86,0x19,0x37,0x49,0xb5,0xe3,0xf0,0xba,0xee,0xac,0xe4,0x18,
	0x9e,0xf6,0x52,0x42,0x18,0x08,0x36,0xb3,0x01,0xf1,0x0a,0xc3,0xb7,0x09,0x3e,0xd8,
	0x76,0x18,0x79,0x98,0x0b,0x14,0xcd,0x0d,0x14,0xa2,0x7e,0xbf,0x52,0x5c,0x61,0x13,
	0x18,0x2e,0x54,0x60,0x9b,0xbb,0x6b,0x94,0xf3,0x21,0xc2,0x52,0x1d,0x6c,0x73,0xb1,
#endif
#if SD_Block_Size >= 128
	0x86,0xc6,0xb6,0x4d,0x8f,0x8d,0x95,0x58,0x66,0x91,0xee,0x13,0xb5,0x81,0xfc,0xd1,
	0xfc,0x7e,0x2a,0xc9,0x7c,0xe1,0x90,0x0f,0xe1,0x87,0x7d,0x6d,0x25,0x10,0x2f,0xa5,
	0x2b,0xe2,0x41,0x4e,0xaa,0xb0,0x2c,0xc6,0x23,0x43,0x83,0x6b,0x02,0xef,0x9a,0x7a,
	0x8d,0xe0,0x9d,0xa0,0x83,0x46,0xf0,0x3a,0x6d,0x32,0x92,0x45,0x92,0xbf,0x53,0x4a,
#endif
#if SD_Block_Size >= 192
	0xbb,0x69,0xd0,0xe3,0xad,0x70,0x43,0xdf,0x50,0x70,0x24,0xdc,0x08,0x85,0x2e,0x33,
	0x96,0x2d,0x15,0xc8,0x6f,0x36,0xea,0xd4,0xfb,0x00,0x58,0x56,0x9c,0x96,0x74,0xaa,
	0xea,0x77,0x1c,0x97,0x20,0x82,0x70,0xb5,0x48,0x95,0x9f,0xe1,0xe9,0xfe,0x4d,0x12,
	0x26,0x2f,0x18,0x19,0x67,0xe4,0x78,0xed,0xdf,0x76,0x08,0xcf,0x30,0x82,0x52,0xdb,
#endif
#if SD_Block_Size >= 256
	0x67,0x96,0xc5,0x0b,0xe0,0x5c,0x15,0x55,0x02,0x94,0x8e,0xb7,0x28,0xbf,0x5d,0xac,
	0xf5,0x34,0x73,0xa8,0x07,0x75,0x62,0x4e,0x24,0xcf,0x6d,0xe2,0xe9,0x87,0xe6,0x1f,
	0xbd,0x1c,0x96,0x5d,0x25,0x82,0xe1,0x9f,0x53,0x7e,0x5d,0x90,0x53,0xb0,0x0d,0x95,
	0x75,0x7c,0xd5,0xfc,0x63,0x6f,0xbd,0xa9,0x80,0xc2,0x63,0x25,0x5e,0x09,0xf9,0xa6,
#endif
#if SD_Block_Size >= 320
	0xc9,0xcc,0xf5,0xfe,0x67,0x91,0x44,0x41,0x00,0x17,0x1c,0x48,0x8f,0x26,0x4d,0x95,
	0x15,0x04,0x38,0x8c,0x90,0x24,0x5b,0xfb,0xd4,0x37,0x4a,0x84,0xc1,0xa0,0x8c,0xfc,
	0x52,0xc6,0xb5,0x43,0x3d,0x9e,0x23,0xb4,0x9d,0xcc,0xb4,0xb4,0x06,0x59,0x33,0x75,
	0x1d,0xb5,0x12,0xa9,0xe3,0x97,0xed,0x17,0xee,0x84,0xbe,0xc8,0xf9,0x23,0x01,0x97,
#endif
#if SD_Block_Size >= 384
	0x37,0x71,0x53,0x0c,0x0b,0xc0,0xb1,0xce,0x8f,0x05,0xb5,0x83,0x74,0x45,0x82,0x0c,
	0x1c,0xd3,0x9c,0x1c,0x05,0x6a,0x8a,0x0e,0x25,0xff,0x00,0xe3,0x53,0xc8,0x9c,0xc0,
	0x40,0xe2,0x60,0x1f,0xa7,0xea,0xa1,0x8e,0x0c,0x56,0x57,0xb7,0x71,0x52,0x07,0xb0,
	0x1a,0x15,0x43,0xd6,0xcc,0x7c,0xb1,0x74,0xe3,0x44,0x19,0xac,0x97,0x96,0xb9,0xd5,
#endif
#if SD_Block_Size >= 448
	0x9e,0x3d,0x7e,0x15,0xd0,0xd5,0x8e,0xcf,0xad,0x7b,0xf9,0x0d,0x13,0xca,0x37,0xc1,
	0x2e,0x49,0x45,0xe2,0xc1,0x96,0xac,0x4e,0x47,0xed,0xa9,0xec,0x94,0x1d,0xdd,0x11,
	0x94,0xf3,0x80,0x88,0xd1,0x22,0xff,0x22,0xcf,0x42,0x03,0x35,0x74,0x10,0x4b,0x3c,
	0xf7,0x49,0xc4,0x2b,0x6d,0x81,0x42,0xfc,0xb3,0x7f,0x19,0x8e,0xc2,0xdd,0x38,0x85,
#endif
#if SD_Block_Size >= 512
	0xb5,0xd9,0xee,0xe5,0xfd,0xbb,0xf3,0xdb,0x60,0xc8,0x84,0xfd,0x9a,0x97,0x79,0x7e,
	0x69,0xab,0x54,0x96,0x3c,0x7a,0xcb,0x7a,0x29,0xdc,0xf8,0x4c,0x24,0x2c,0x99,0xf1,
	0x6f,0x04,0x27,0x35,0x0d,0xca,0x62,0x5b,0xfc,0xeb,0x4c,0xd5,0xc2,0x93,0xf2,0xa9,
	0x31,0xf3,0x3a,0xff,0x49,0xa0,0xbc,0xbc,0x55,0xeb,0x3d,0xa9,0x02,0x21,0xe1,0x48,
#endif
};
#  define TEST_DATA random_block

#else

static block test;
#  define TEST_DATA test.dat

#endif

static block buffer[SD_Block_Test_Count];

static uint8_t CS_pin = 4;

static uint8_t SIGNAL_pin = 8;

static uint32_t blockAddr = 1;

static Sd2Card SDC;

//----------------------------------------------------------------------------
//The setup function is called once at startup of the sketch
void setup()
{  // Open serial communications and wait for port to open:
	Serial.begin( 9600 );
	while( !Serial )
	{
		; // wait for serial port to connect. Needed for Leonardo only
	}

	Serial.println( "Test Parameters:" );
	Serial.print( "Starting address = " );
	Serial.println( blockAddr, HEX );
	Serial.print( "SD_Block_Size = " );
	Serial.println( SD_Block_Size );
	Serial.print( "SD_Block_Test_Count = " );
	Serial.println( SD_Block_Test_Count );

	Serial.print( "\nInitializing SD card..." );
	// On the Ethernet Shield, CS is pin 4. It's set as an output by default.
	// Note that even if it's not used as the CS pin, the hardware SS pin
	// (10 on most Arduino boards, 53 on the Mega) must be left as an output
	// or the SD library functions will not work.
	fast_pinMode( 10, OUTPUT );     // change this to 53 on a mega

	fast_pinMode( SIGNAL_pin, OUTPUT );
	fast_digitalWrite(SIGNAL_pin,HIGH);
	// we'll use the initialization code from the utility libraries
	// since we're just testing if the card is working!
	if( !SDC.init( SPI_FULL_SPEED, CS_pin ) )
	{
		Serial.println( "initialization failed. Things to check:" );
		Serial.println( "* is a card is inserted?" );
		Serial.println( "* Is your wiring correct?" );
		Serial.println(
				"* did you change the chipSelect pin to match your shield or module?" );
		return;
	}
	else
	{
		Serial.println( "Wiring is correct and a card is present." );
	}

	while( SDC.isBusy() )
		;

#ifdef TEST_SEQUENTIAL
	Serial.println( "Test is SEQUENTIAL" );
#else
	Serial.println("Test is not SEQUENTIAL");
#endif

	Serial.println( "Setup Complete!" );
}

//----------------------------------------------------------------------------
// The loop function is called in an endless loop
void loop()
{
	// read any existing Serial data
	while( Serial.read() >= 0 )
	{
	}

	// pstr stores strings in flash to save RAM
	Serial.print( "\ntype any character to start\n" );
	while( Serial.read() <= 0 )
	{
	}
	delay( 400 );  // catch Due reset problem

	for( size_t i = 0; i < SD_Block_Test_Count; ++i )
	{
		fillBlock( buffer[i].dat );
	}

// Perform read-write test on multiple blocks
#if SD_Block_Test_Count > 1
	fast_digitalWrite(SIGNAL_pin,LOW);
	// Multi-block write test
	SDC.writeStart( blockAddr , SD_Block_Test_Count );
	for( size_t i=0; i<SD_Block_Test_Count; ++i)
	{	SDC.writeData( buffer[i].dat );
	}
	SDC.writeStop();
	fast_digitalWrite(SIGNAL_pin,HIGH);

	for( size_t i=0; i<SD_Block_Test_Count; ++i)
	{	eraseBlock( buffer[i].dat );
	}

	fast_digitalWrite(SIGNAL_pin,LOW);
	// Multi-block read test
	SDC.readStart( blockAddr );
	for( size_t i=0; i<SD_Block_Test_Count; ++i)
	{	SDC.readData( buffer[i].dat );
	}
	SDC.readStop();
	fast_digitalWrite(SIGNAL_pin,HIGH);

#endif

// Perform read-write test on one block
#if SD_Block_Test_Count == 1

	fast_digitalWrite(SIGNAL_pin,LOW);
	// Single-block write test
	SDC.writeBlock( blockAddr, buffer[0].dat );
	fast_digitalWrite(SIGNAL_pin,HIGH);

	eraseBlock( buffer[0].dat );

	fast_digitalWrite(SIGNAL_pin,LOW);
	// Single-block read test
	SDC.readBlock( blockAddr, buffer[0].dat );
	fast_digitalWrite(SIGNAL_pin,HIGH);
#endif

#if SD_Block_Test_Count
	for( size_t i = 0; i < SD_Block_Test_Count; ++i )
	{
		Serial.print( "Block number " );
		Serial.print( i );
		uint8_t * err_ptr = verifyBlock( buffer[i].dat ) ;
		if( err_ptr != NULL )
		{
			Serial.print( " does not match. " );
			Serial.print( "(error at byte #" );
			Serial.print( buffer[i].dat - err_ptr );
			Serial.print( ")\n" );
		}
		else
		{
			Serial.println( " matches." );
		}
		printBlock( buffer[i].dat );
	}
#endif

//	while(1);
}

inline
void fillBlock( uint8_t * dat )
{
	for( uint32_t ii = 0; ii < SD_Block_Size; ii++ )
	{

#ifdef TEST_SEQUENTIAL
		dat[ii] = ii;
#else
		dat[ii] = random_block[ii];
#endif

	}
}
inline
void eraseBlock( uint8_t * dat )
{
	for( uint32_t ii = 0; ii < SD_Block_Size; ii++ )
	{
		dat[ii] = 0;
	}
}
inline
uint8_t * verifyBlock( uint8_t * dat )
{
	for( uint32_t ii = 0; ii < SD_Block_Size; ii++ )
	{
		if( dat[ii] != TEST_DATA[ii] )
		{
			return &dat[ii];
		}
	}
	return NULL;
}
inline
String byte2hex(byte b)
{
	String ret;
	const byte nib[2] = { byte((b>>4)&0x0F), byte((b)&0x0F) };
	ret+="0x";
	for(byte i=0; i<2; ++i )
	switch (nib[i]) {
		case 0x0:ret+='0';break;
		case 0x1:ret+='1';break;
		case 0x2:ret+='2';break;
		case 0x3:ret+='3';break;
		case 0x4:ret+='4';break;
		case 0x5:ret+='5';break;
		case 0x6:ret+='6';break;
		case 0x7:ret+='7';break;
		case 0x8:ret+='8';break;
		case 0x9:ret+='9';break;
		case 0xa:ret+='a';break;
		case 0xb:ret+='b';break;
		case 0xc:ret+='c';break;
		case 0xd:ret+='d';break;
		case 0xe:ret+='e';break;
		case 0xf:ret+='f';break;
	}
	return ret;
}

inline
void printBlock( uint8_t * dat )
{
	for( uint32_t ii = 0; ii < SD_Block_Size; ii++ )
	{
		if( ii % 16 == 0 ) Serial.print( "\n" );
		Serial.print( byte2hex(dat[ii]) + " " );
	}
}

